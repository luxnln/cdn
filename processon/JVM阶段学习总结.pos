{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[],"title":"JVM","root":true,"theme":"theme3","children":[{"id":"7fc429f902d8","title":"JVM简介","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"id":"7c7309c0962d","title":"什么是JVM？","children":[{"id":"a6fa5666164a","title":"&nbsp; JVM(Java Virtual Mechine)即java虚拟机，是一个通过在现实计算机上，<br>模拟和仿真计算机各种功能的虚拟计算机。","children":[],"parent":"7c7309c0962d"}],"parent":"7fc429f902d8"},{"id":"655473a07877","title":"JVM作用？","parent":"7fc429f902d8","children":[{"id":"dc534ee2407d","title":"&nbsp; 把Java语言与平台(硬件或操作系统)分隔开来，同一个java编译出来的目标文件，<br>可以不加修改的在不同平台或是操作系统正常运行，即实现跨平台。","parent":"655473a07877","children":[]}]}],"parent":"root","collapsed":false},{"id":"2b4e623aaba4","title":"JVM内存区域划分","lineStyle":{"randomLineColor":"#0FBAB0"},"parent":"root","children":[{"id":"d40c1bdd578a","title":"PC寄存器","children":[{"id":"3a6705ea9e92","title":"属于线程独占。","children":[],"parent":"d40c1bdd578a"},{"id":"2bd1c01262fb","title":"作用是保存当前线程执行到的JVM指令地址。保证线程后能恢复到正确位置继续运行。","children":[],"parent":"d40c1bdd578a"}],"parent":"2b4e623aaba4"},{"id":"e3636c0943e9","title":"虚拟机栈","children":[{"id":"cb005ca83bc2","title":"属于线程独占。","children":[],"parent":"e3636c0943e9"},{"id":"f06adfed3b8f","title":"作用是描述java方法执行的内存模型。每一个方法执行的时候都会创建一个栈帧。方法被调用到执行结束就对应着栈帧入栈和出栈的过程。","parent":"e3636c0943e9","children":[]},{"id":"193ef992779c","title":"每一个栈帧中包含了：局部变量表、操作栈、动态链接和方法出口等信息","children":[],"parent":"e3636c0943e9"}],"parent":"2b4e623aaba4"},{"id":"d9aa0ac4280e","title":"本地方法栈","children":[{"id":"e927865e3bf3","title":"属于线程独占。","children":[],"parent":"d9aa0ac4280e"},{"id":"0ccdd6020d42","title":"作用与虚拟机栈一致。不同的在于，虚拟机栈是服务Java方法的，而本地方法栈是服务于虚拟机使用到的本地方法。","children":[],"parent":"d9aa0ac4280e"}],"parent":"2b4e623aaba4"},{"id":"f4a365c6266a","title":"堆","children":[{"id":"37529ee913d1","title":"属于线程共享。","parent":"f4a365c6266a","children":[]},{"id":"b28fc87b1ee2","title":"作用是存放对象实例和数组（几乎所有的对象实例和数组都存放在堆中）。","parent":"f4a365c6266a","children":[]},{"id":"3749a7d45a0a","title":"物理空间可以是不连续的。内存可以是固定大小也可以是扩展的(大多都是扩展的)。是垃圾收集器主要管理区域。","children":[],"parent":"f4a365c6266a"}],"parent":"2b4e623aaba4"},{"id":"d644adb3eee7","title":"方法区","children":[{"id":"b940b80b2361","title":"属于线程共享。","children":[],"parent":"d644adb3eee7"},{"id":"fbd5839930b0","title":"作用是存储已被虚拟机加载的存放类信息、静态变量、常量和即时编译器编译后的代码等数据。","children":[],"parent":"d644adb3eee7"},{"id":"1b41e21bd35d","title":"JDK1.8之前HotSpot使用永久代来实现方法区。而在1.8之后，则使用元数据区取代了方法区，并将空间从虚拟机内存中移到了直接内存中。","children":[],"parent":"d644adb3eee7"},{"id":"a1ae4002531e","title":"物理空间可以不连续。内存可以是固定大小也可以是扩展的。可以选择不实现垃圾收集。","parent":"d644adb3eee7","children":[]},{"id":"9c72ae61c86f","title":"运行时常量池","children":[{"id":"7f8200d99a34","title":"是方法区的一部分。","parent":"9c72ae61c86f","children":[]},{"id":"122fd699454f","title":"作用是存放编译期生成的各种字面量和符号引用。(在Class文件被虚拟机加载后放在此处)","parent":"9c72ae61c86f","children":[]}],"parent":"d644adb3eee7"}],"parent":"2b4e623aaba4"},{"id":"8557a3b2a50b","title":"直接内存","children":[{"id":"3d7bc4410683","title":"直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用。<br>例如，在NIO中有提供对直接内存操作的对象。","children":[],"parent":"8557a3b2a50b"}],"parent":"2b4e623aaba4"}]},{"id":"6100bb22d72b","title":"垃圾收集","lineStyle":{"randomLineColor":"#FA5465"},"parent":"root","children":[{"id":"b1394e4b0a15","title":"如何判断一个对象可被回收？","parent":"6100bb22d72b","children":[{"id":"0c3ed3c3a7cb","title":"引用计数算法","children":[{"id":"ecf3d4c4482e","title":"当一个对象被引用时计数加一，当引用失效后计数减一。<br>但是因为很难解决循环引用的问题，Java并没使用该算法。","children":[],"parent":"0c3ed3c3a7cb"}],"parent":"b1394e4b0a15"},{"id":"e98ac0d9322b","title":"根搜索算法<br>","children":[{"id":"b3fdd9f3c43a","title":"通过一些列名为“GC Roots”的作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链(Reference Chain)，<br>当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。(可以理解为图中的不可达的点)","children":[],"parent":"e98ac0d9322b"},{"id":"a1c0c0537c8c","title":"在Java中可以作用GC Roots的对象有：","children":[{"id":"15c833cd8868","title":"虚拟机栈(栈帧中的本地变量表)中的引用的对象<br>","parent":"a1c0c0537c8c","children":[]},{"id":"95da9b6eece6","title":"本地方法栈中JNI(即Native方法)的引用的对象<br>","parent":"a1c0c0537c8c","children":[]},{"id":"5c312cdd1d5b","title":"方法区中的类静态属性引用的对象<br>","children":[],"parent":"a1c0c0537c8c"},{"id":"e6d6f862442a","title":"方法区中的常量引用的对象","children":[],"parent":"a1c0c0537c8c"}],"parent":"e98ac0d9322b"}],"parent":"b1394e4b0a15"},{"id":"977392edd3e7","title":"方法区的回收","children":[{"id":"4e1384ef8927","title":"这块区域的垃圾回收收集主要回收两个部分内容：废弃常量和无用的类。","children":[],"parent":"977392edd3e7"}],"parent":"b1394e4b0a15"},{"id":"8b94225e40f2","title":"关于引用类型","parent":"b1394e4b0a15","children":[{"id":"afae186de58b","title":"强引用：类似于Object b = new Object();这种，只要强引用在，则该对象就永远不会被垃圾收集器回收。","parent":"8b94225e40f2","children":[]},{"id":"c970661b4ff0","title":"软引用：SoftReference类。一些有用但不是必需的对象。当垃圾回收了一次之后，还是有内存溢出的风险时，才会把软引用也作为回收范围，进行第二次回收。","children":[],"parent":"8b94225e40f2"},{"id":"30fe627e983b","title":"弱引用：WeakReference类。不是必需的对象。只能活到下一次内存回收。","parent":"8b94225e40f2","children":[]},{"id":"b806cbb45d82","title":"虚引用：PhantomReference类。不影响一个对象的生存时间，也无法通过虚引用来获取一个对象。它的作用仅仅是在对象被回收是，给出一个系统通知。","children":[],"parent":"8b94225e40f2"}]}]},{"id":"7e13eadec8f9","title":"垃圾收集算法","children":[{"id":"980bbe75b67f","title":"标记-清除算法","parent":"7e13eadec8f9","children":[{"id":"12c1cf7cf7ea","title":"标记和清除效率都不高，并且会产生空间碎片的问题。","children":[],"parent":"980bbe75b67f"}]},{"id":"7d974d887f0a","title":"复制算法","children":[{"id":"83d7dccb6820","title":"实现简单，运行高效。但是会浪费空间，而且当存活对象率高时，过多的复制操作效率会降低。","parent":"7d974d887f0a","children":[]}],"parent":"7e13eadec8f9","collapsed":false},{"id":"cf86c87a79e8","title":"标记-整理算法","parent":"7e13eadec8f9","children":[{"id":"88aca88cf4bc","title":"标记和整理的效率也都不高。但是不会有空间碎片的问题。主要时用于对象活的比较久的老年代中。","parent":"cf86c87a79e8","children":[]}]},{"id":"25b21983503a","title":"分代收集算法","parent":"7e13eadec8f9","children":[{"id":"8c6dd99e0a44","title":"把Java堆分成新生代和老年代，这样就可以根据各年代的特点采用最适当的收集算法","parent":"25b21983503a","children":[]}]}],"parent":"6100bb22d72b"},{"id":"17bc8b387ea8","title":"垃圾收集器","children":[{"id":"c3915ea68baa","title":"Serial","parent":"17bc8b387ea8","children":[{"id":"d98e127cb268","title":"最悠久的垃圾收集器。新生代，复制算法，单线程。","children":[],"parent":"c3915ea68baa"},{"id":"5e161364a09b","title":"优点：简单高效。","children":[],"parent":"c3915ea68baa"},{"id":"c2ab21c85e2f","title":"缺点：单线程，有停顿。","children":[],"parent":"c3915ea68baa"}]},{"id":"6e5810809b6b","title":"ParNew","parent":"17bc8b387ea8","children":[{"id":"c01716c57105","title":"新生代，复制算法，多线程。","parent":"6e5810809b6b","children":[]},{"id":"fe300cc7b21e","title":"ParNew其实就是Serial的多线程版本。","parent":"6e5810809b6b","children":[]}]},{"id":"a477a1231e3c","title":"Parallel savenge","parent":"17bc8b387ea8","children":[{"id":"55918b0bcae5","title":"新生代，复制算法，多线程。","parent":"a477a1231e3c","children":[]},{"id":"33c5b823dcdb","title":"以最大吞吐量为目标。可以通过-XX:MaxGCPauseMillis最大GC停顿时间和-XX:GCTimeRadio吞吐量来精确控制吞吐量。","children":[],"parent":"a477a1231e3c"},{"id":"9950946ebd4d","title":"可以使用-XX:+UseAdaptiveSizePolicy打开 GC 自适应的调节策略。虚拟机会根据当前系统的运行情况收集性能监控信息，<br>动态调整这些参数以提供最合适的停顿时间或者最大的吞吐","parent":"a477a1231e3c","children":[]}]},{"id":"2debcaad0c18","title":"Parallel Old","children":[{"id":"30d4f6ed2045","title":"老年代，标记-整理算法，多线程。","children":[],"parent":"2debcaad0c18"},{"id":"5afacf94b277","title":"Parallel Savenge的老年代版本。","children":[],"parent":"2debcaad0c18"},{"id":"61591d49d559","title":"Parallel Savenge和Parallel Old组合起来适合在注重吞吐量和对CPU资源敏感的场景。","children":[],"parent":"2debcaad0c18"}],"parent":"17bc8b387ea8"},{"id":"21ec246d7478","title":"Serial Old","parent":"17bc8b387ea8","children":[{"id":"07900e7b039d","title":"老年代，标记-整理算法，单线程。","children":[],"parent":"21ec246d7478"},{"id":"abe3f050fe08","title":"Serial 的老年代版本","children":[],"parent":"21ec246d7478"},{"id":"eb8aa5cb61f3","title":"作用：一个是在JDK1.5之前，也就是Parallel Old出来之前与Parall Savenge配合使用；<br>另一个是作用CMS发生Concurren Mode Failure的备用预案。","children":[],"parent":"21ec246d7478"}]},{"id":"6e00422fc3f6","title":"CMS","parent":"17bc8b387ea8","children":[{"id":"b0382c17a25b","title":"老年代，标记-清除算法，多线程。","parent":"6e00422fc3f6","children":[]},{"id":"e884f4fa4d82","title":"以最短停顿时间为目标。适用于注重服务器响应速度的场景。","parent":"6e00422fc3f6","children":[]},{"id":"f059fcbe6f37","title":"运作过程分为四步：1. 初始标记；2. 并发标记；3. 重新标记；4.并发清除","children":[],"parent":"6e00422fc3f6"},{"id":"8ec3bfa1dce6","title":"优点：低停顿，并发收集。","children":[],"parent":"6e00422fc3f6"},{"id":"e2b16c095809","title":"缺点：低停顿牺牲了吞吐量；很难处理浮动垃圾，容易导致ConcurrenModeFailure；标记-清除算法带来的碎片空间问题。","parent":"6e00422fc3f6","children":[]}]},{"id":"a4e081cfeafd","title":"G1","parent":"17bc8b387ea8","children":[{"id":"8d038a028ed3","title":"用来代替CMS，在多CPU和大内存的场景下有很好的性能。","parent":"a4e081cfeafd","children":[]},{"id":"d8bbf15187f5","title":"G1把堆分成了若干个大小一致的区域(Region)，新生代与老年代不再物理隔离。监控着每一个区域的垃圾堆积程度，并维护一个优先列表。<br>每次根据允许的收集时间，优先回收垃圾最多的区域，能再有限的时间内获取到最大的垃圾回收效率。","parent":"a4e081cfeafd","children":[]},{"id":"a05b4e1cd6d9","title":"它可以非常精确地控制停顿，即能让使用者明确指定在一个长度为M毫秒地时间片段内，消耗在垃圾收集上地时间不超过N毫秒。","parent":"a4e081cfeafd","children":[]}]}],"parent":"6100bb22d72b"}]},{"id":"0a9fcc93eda3","title":"内存分配与回收策略","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"id":"46bdd398493b","title":"内存分配策略","parent":"0a9fcc93eda3","children":[{"id":"e1978c80b0fe","title":"对象优先在Eden区域分配","children":[],"parent":"46bdd398493b"},{"id":"54777364203d","title":"大对象直接分配在老年代","children":[{"id":"65f745752c2c","title":"一般有一个参数指定到底多大。而在jdk1.8的Parallel Scavenge垃圾回收器中判断一个大对象的标准是该对象大小是否大于Eden的一半。","children":[],"parent":"54777364203d"}],"parent":"46bdd398493b"},{"id":"b36bca4b5507","title":"长期存活的对象进入到老年代","children":[{"id":"a192d8298682","title":"虚拟机为每个对象定义了一个对象年龄(Age)计数器。每一次Minor GC存活后年龄加一，当达到一定的年龄后，会晋升到老年代中。","parent":"b36bca4b5507","children":[]}],"parent":"46bdd398493b"},{"id":"7e857f6c6ac6","title":"动态年龄判断","children":[{"id":"dc3f2f516271","title":"并不是一定要达到指定的年龄才能进入到老年代。当Survivor区域中相同年龄的对象总大小大于了Survivor区域的一半，<br>则所有大于等于该年龄的对象都晋升到老年代","children":[],"parent":"7e857f6c6ac6"}],"parent":"46bdd398493b"},{"id":"43efa7b6f7a4","title":"空间分配担保","parent":"46bdd398493b","children":[{"id":"721c0275983d","title":"为了防止Survivor中大量对象存活，导致没有足够的空间放对象。所以需要老年代来对其进行担保，把Survivor放不下的对象放入到老年代中。","parent":"43efa7b6f7a4","children":[]},{"id":"e73bc0e00202","title":"在发生Minor GC前，先检查老年代中最大的可用连续空间是否大于新生代中所有对象的空间或者大于历次晋升的平均大小。若是大于，则直接Minor GC。否则，先进行一次Full GC。","parent":"43efa7b6f7a4","children":[]},{"id":"c8b5f3aeb59f","title":"jdk1.6之前会根据HandlePromotionFailure参数来判断是否允许空间分配担保。","parent":"43efa7b6f7a4","children":[]}]}]},{"id":"2d444f4120f4","title":"FullGC触发条件","children":[{"id":"a23acbf8617d","title":"System.gc()","parent":"2d444f4120f4","children":[]},{"id":"163efab3ffb4","title":"老年代空间不足","parent":"2d444f4120f4","children":[]},{"id":"a4b29552b493","title":"空间分配担保失败","parent":"2d444f4120f4","children":[]},{"id":"b9c8786f050c","title":"jdk1.7之前的永久代空间不足","parent":"2d444f4120f4","children":[]},{"id":"75ae81b265b8","title":"CMS发生Concurrent Mode Failure","children":[],"parent":"2d444f4120f4"}],"parent":"0a9fcc93eda3"}],"parent":"root"},{"id":"9323fcf503cf","title":"类加载机制","lineStyle":{"randomLineColor":"#FD5155"},"parent":"root","children":[{"id":"e62d7b5182ee","title":"类的生命周期","children":[{"id":"1b22935070d9","title":"加载、验证、准备、解析、初始化、使用、卸载","children":[],"parent":"e62d7b5182ee"}],"parent":"9323fcf503cf"},{"id":"01329af5bd38","title":"类加载过程","children":[{"id":"af4dcd892670","title":"加载：加载时是类加载的一个过程。","parent":"01329af5bd38","children":[{"id":"ab4019fc1c04","title":"通过类的完全限定名获取该类的二进制字节流；","parent":"af4dcd892670","children":[]},{"id":"ed64c8824267","title":"将该字节流表示的静态存储结构转化成方法区的运行时存储结构；","parent":"af4dcd892670","children":[]},{"id":"e83a784594ca","title":"在内存中生成一个该类的Class对象，作为方法区中该类各种数据的访问入口。","parent":"af4dcd892670","children":[]}]},{"id":"7184ce59dfaa","title":"验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。","children":[],"parent":"01329af5bd38"},{"id":"cf532a8b829e","title":"准备：为类变量分配空间并设置初始值。注意：此处的初始值一般是零值，而不是代码中指定的值。除非是常量。","children":[],"parent":"01329af5bd38"},{"id":"57385c264740","title":"解析：将常量池的符号引用替换为直接引用的过程。","children":[],"parent":"01329af5bd38"},{"id":"a0e1a901ddfc","title":"初始化：初始化是类加载过程的最后一步，此时才真正开始执行类中定义的Java程序代码（字节码）。","children":[],"parent":"01329af5bd38"}],"parent":"9323fcf503cf"},{"id":"9ecbb7d778c2","title":"类初始化的时机","children":[{"id":"2e99d2a7b371","title":"1. 遇到new、getstatic、putstatic或invokestatic这4条JVM指令时，如果类没有进行初始化，则需要先触发其初始化。","children":[{"id":"68aedfea22a1","title":"包括了new一个实例对象；读取或设置一个类静态变量；调用类的静态方法等。","children":[],"parent":"2e99d2a7b371"}],"parent":"9ecbb7d778c2"},{"id":"9e5acf7a03b0","title":"2. 使用java.util.reflect包对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。<br>","children":[],"parent":"9ecbb7d778c2"},{"id":"38b75eb79f0d","title":"3. 当初始一个类的时候，发现其父类还没有初始化，则先对父类进行初始化。","children":[],"parent":"9ecbb7d778c2"},{"id":"e335e45213e3","title":"4. 当程序启动的时候，虚拟机会先初始化主类（即包含main()方法的类）。","children":[],"parent":"9ecbb7d778c2"}],"parent":"9323fcf503cf"},{"id":"c80746981dd7","title":"类加载器","children":[{"id":"bdd99271cc32","title":"启动类加载器(Bootstrap Classloader)","children":[{"id":"87bb3ebc7a52","title":"C++实现，是虚拟机的一部分。负责加载 &lt;JRE_HOME&gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库。程序员无法直接调用。","children":[],"parent":"bdd99271cc32"}],"parent":"c80746981dd7"},{"id":"8e7cf2671f95","title":"扩展类加载器(Extention Classloader)","children":[{"id":"aa4d79fe870f","title":"Java实现(ExtClassLoader)，负责加载 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库，程序员可以直接使用。","children":[],"parent":"8e7cf2671f95"}],"parent":"c80746981dd7"},{"id":"b8ba131fbcc1","title":"应用程序类加载器(Application Classloader)","children":[{"id":"b4a9ed262456","title":"Java实现(AppClassLoader)，负责加载用户类路径（ClassPath）上所指定的类库，程序员可以直接使用。","children":[],"parent":"b8ba131fbcc1"}],"parent":"c80746981dd7"}],"parent":"9323fcf503cf"},{"id":"23ac2e49e011","title":"双亲委派模型","children":[{"id":"199aa91cf39d","title":"描述类加载器之间层次关系的模型。","children":[],"parent":"23ac2e49e011"},{"id":"98e60edf2d47","title":"该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系来实现","children":[],"parent":"23ac2e49e011"},{"id":"6a98350de46d","title":"工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。","children":[],"parent":"23ac2e49e011"},{"id":"98e96603fc8d","title":"好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。","children":[],"parent":"23ac2e49e011"}],"parent":"9323fcf503cf"}]}]}},"meta":{"id":"5fd74349e401fd06ddc3254f","member":"5fa7ad757d9c081baf1d7fac","exportTime":"2020-12-14 20:42:48","diagramInfo":{"category":"mind_free","title":"JVM阶段学习总结","created":"2020-12-14 18:49:45","creator":"5fa7ad757d9c081baf1d7fac","modified":"2020-12-14 20:42:38"},"type":"ProcessOn Schema File","version":"1.0"}}