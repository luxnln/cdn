{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[{"id":"5367f7226cd3","title":"多线程的实现方式","children":[{"id":"b500ecf21b50","title":"继承Thread类","children":[],"parent":"5367f7226cd3"},{"id":"2995695ab592","title":"实现Runnable接口","children":[],"parent":"5367f7226cd3"},{"id":"c10c12a0061f","title":"实现Callable接口","children":[],"parent":"5367f7226cd3"},{"id":"25349d7bf102","title":"使用线程池","style":{"font-style":"italic"},"children":[],"parent":"5367f7226cd3","note":"线程池只是启动线程，或是执行任务。线程要执行的代码，还是在Runnable或Callable中实现。"}],"parent":"root","note":""},{"id":"56fda8f513ba","title":"线程同步","children":[{"id":"0566e484c10f","title":"synchronized","children":[{"id":"018434dde49d","title":"同步代码块","children":[],"parent":"0566e484c10f"},{"id":"e748899ca85c","title":"同步方法","children":[],"parent":"0566e484c10f"},{"id":"fe8b2476f514","title":"静态同步代码块","children":[],"parent":"0566e484c10f"},{"id":"445750756b09","title":"静态同步方法","children":[],"parent":"0566e484c10f"}],"parent":"56fda8f513ba"},{"id":"e9caad6c34ba","title":"ReetrantLock","children":[],"parent":"56fda8f513ba"},{"id":"506472ff2ad3","title":"synchronized与ReetrantLock的区别？","children":[{"id":"813ed641ef01","title":"实现？","children":[],"parent":"506472ff2ad3"},{"id":"814ebd872c04","title":"等待可中断？","children":[],"parent":"506472ff2ad3"},{"id":"c41510297282","title":"公平锁？","children":[],"parent":"506472ff2ad3"},{"id":"cb58d3ef455e","title":"锁的释放？","children":[],"parent":"506472ff2ad3"},{"id":"29cb6300948e","title":"能否判断锁的状态？","children":[],"parent":"506472ff2ad3"}],"parent":"56fda8f513ba"}],"parent":"root"},{"id":"9dc7222b3df9","title":"java内存模型","children":[{"id":"742c45902adc","title":"什么是内存模型？","children":[{"id":"52cc75704aab","title":"java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。","parent":"742c45902adc","children":[]}],"parent":"9dc7222b3df9"},{"id":"30e822f63dd2","title":"内存之间的8个操作","children":[{"id":"fb0994eea19c","title":"read","children":[],"parent":"30e822f63dd2"},{"id":"4e305c0d48c8","title":"load","children":[],"parent":"30e822f63dd2"},{"id":"42ca1de875c9","title":"use","children":[],"parent":"30e822f63dd2"},{"id":"348418037211","title":"assgin","children":[],"parent":"30e822f63dd2"},{"id":"e20099edfb59","title":"stroe","children":[],"parent":"30e822f63dd2"},{"id":"4abc720aac4a","title":"write","children":[],"parent":"30e822f63dd2"},{"id":"d9cc43a4a7a9","title":"lock","children":[],"parent":"30e822f63dd2"},{"id":"0c61d9deb284","title":"unlock","children":[],"parent":"30e822f63dd2"}],"parent":"9dc7222b3df9"},{"id":"d7bab0468261","title":"内存模型的实质","children":[{"id":"66291743c75e","title":"原子性","children":[{"id":"47cc0953dcc1","title":"<ol><li>基础数据类型对应的Atomic包装类</li><li>synchronized</li></ol>","parent":"66291743c75e","children":[]}],"parent":"d7bab0468261"},{"id":"72b37c0d3fc5","title":"可见性","children":[{"id":"345fcaabfc74","title":"<ol><li>synchronized</li><li>volatile</li><li>final</li></ol>","children":[],"parent":"72b37c0d3fc5"}],"parent":"d7bab0468261","collapsed":false},{"id":"8bfaa171fedf","title":"有序性","children":[{"id":"5b593258ec73","title":"<ol><li>synchronized</li><li>volatile</li></ol>","children":[],"parent":"8bfaa171fedf"}],"parent":"d7bab0468261"}],"parent":"9dc7222b3df9"}],"parent":"root"},{"id":"f82b9dc2a04d","title":"线程池","parent":"root","children":[{"id":"c5b8ec64a38d","title":"什么是线程池？","parent":"f82b9dc2a04d","children":[{"id":"ea9d259947cc","title":"线程池，是一种线程的使用模式。它通过复用线程，来降低线程频繁地创建和销毁所造成地的资源消耗","parent":"c5b8ec64a38d","children":[]}]},{"id":"7d57af1840c6","title":"常用线程池","parent":"f82b9dc2a04d","children":[{"id":"5366bf2f061b","title":"CachedThreadPool","parent":"7d57af1840c6","children":[]},{"id":"04d5b05e3aac","title":"FixedThreadPool","parent":"7d57af1840c6","children":[]},{"id":"ee75af776bac","title":"SingleThreadExecutor","parent":"7d57af1840c6","children":[]},{"id":"5323ba4dd643","title":"ScheduledThreadPool","parent":"7d57af1840c6","children":[]}]},{"id":"fda36b623b94","title":"自定义线程池(ThreadPoolExecutor)","parent":"f82b9dc2a04d","children":[{"id":"b3c519479442","title":"corePoolSize","children":[],"parent":"fda36b623b94"},{"id":"dcec2be26012","title":"maximumPoolSize","children":[],"parent":"fda36b623b94"},{"id":"34816b9ea70e","title":"keepAliveTime","children":[],"parent":"fda36b623b94"},{"id":"d7562a797a33","title":"unit","parent":"fda36b623b94","children":[]},{"id":"23d0a9835c62","title":"workQueue","parent":"fda36b623b94","children":[]},{"id":"f0399d760f03","title":"eejectedExecutionHandler","parent":"fda36b623b94","children":[]},{"id":"93b89697d4bf","title":"threadFactory","parent":"fda36b623b94","children":[]}]}],"collapsed":false}],"title":"多线程阶段学习总结","root":true,"theme":"theme3","children":[{"id":"622edb2459ec","title":"多线程简介","children":[{"id":"3ab90671404e","title":"什么是多线程？","parent":"622edb2459ec","children":[{"id":"839485460024","title":"多线程就是在一个程序中可以创建并同时运行多个不同的线程，来完成任务","parent":"3ab90671404e","children":[]}]},{"id":"fdf2b01f63ca","title":"多线程的优点？","parent":"622edb2459ec","children":[{"id":"a55db38609ad","title":"1、提高CPU利用率； 2、提升程序软件友好度","parent":"fdf2b01f63ca","children":[]}]},{"id":"ef87bbee4224","title":"什么是进程？","parent":"622edb2459ec","children":[{"id":"faed95c95121","title":"进程是操作系统资源分配的基本单位，进程就是一个程序","children":[],"parent":"ef87bbee4224"}]},{"id":"35bd03c0a5cf","title":"什么是线程？","parent":"622edb2459ec","children":[{"id":"beaa70d297b7","title":"线程是cpu调度和执行的最小单位，线程就是进程中实际运作的一条流程","children":[],"parent":"35bd03c0a5cf"}]},{"id":"d438d788121b","title":"进程和线程的区别？","parent":"622edb2459ec","children":[{"id":"c59b776d70fa","title":"根本区别：进程是操作系统资源分配的基本单位，线程是cpu调度和执行的最小单位","children":[],"parent":"d438d788121b"},{"id":"6cabcdaf1427","title":"资源开销：每个进程都有独立的代码和数据空间，进程切换消耗大。同一个进程下的线程共享进程的代码和数据空间，但是每个进程都有自己的运行栈和pc，线程的切换比之进程小","children":[],"parent":"d438d788121b"},{"id":"3b5fa083225d","title":"关系：一个进程至少有一个线程","children":[],"parent":"d438d788121b"}]},{"id":"b98d9249a57f","title":"协程又是什么？","children":[{"id":"9dd7e0fd229a","title":"协程是一个特殊的函数，可以在某个地方被挂起，然后再其它地方被唤醒继续执行。它不归操作系统管，而是完全有程序控制。即使一个线程有多个协程，但一个线程内协程却绝对是串行的。并且协程无法利用cpu并行执行。","children":[],"parent":"b98d9249a57f"}],"parent":"622edb2459ec"}],"parent":"root"},{"id":"9a7c239eaaec","title":"线程的常用方法","children":[{"id":"364ec7dc3c24","title":"getName()：获取线程名称","children":[],"parent":"9a7c239eaaec"},{"id":"991ba14300d7","title":"setDeamon()：守护线程<br>","parent":"9a7c239eaaec","children":[]},{"id":"0c5bb12fb664","title":"isAlive()：线程是否存活","children":[],"parent":"9a7c239eaaec"},{"id":"c44c7e525870","title":"<span style=\"font-size: inherit;\">线程的通信：<br><ol><li><span style=\"font-size: inherit;\">wait()、notify()、notifyAll()</span></li><li>await()、signal()、signalAll()</li></ol></span>","parent":"9a7c239eaaec","children":[]},{"id":"8f228ee09eec","title":"Thread.sleep()：休眠","children":[],"parent":"9a7c239eaaec"},{"id":"984c7c589b83","title":"中断：<br>interrupt()、interrupted()<br>Executor的shutdown()、shtudownNow()<br>","children":[],"parent":"9a7c239eaaec"},{"id":"4e102e09bec3","title":"yield()：让线程重新回到就绪状态","parent":"9a7c239eaaec","children":[]},{"id":"eb0c2108ea12","title":"stop()、suspend()、resum()","style":{"font-style":"italic","text-decoration":"line-through"},"parent":"9a7c239eaaec","children":[],"note":"容易死锁，不建议使用。"}],"parent":"root"},{"id":"a5db81c9f5a5","title":"线程的生命周期（状态）","children":[{"id":"b95c9a511873","title":"新建(New)","children":[],"parent":"a5db81c9f5a5"},{"id":"891bc0e40007","title":"就绪(Runnable)","children":[],"parent":"a5db81c9f5a5"},{"id":"71b482a9fe23","title":"运行(Running)","children":[],"parent":"a5db81c9f5a5"},{"id":"1426c5fe8b06","title":"死亡(Dead)","children":[],"parent":"a5db81c9f5a5"},{"id":"76d8f030deb4","title":"阻塞(Blcoked)","children":[{"id":"806f04f8d858","title":"同步阻塞","children":[],"parent":"76d8f030deb4"},{"id":"d48502fccb72","title":"等待阻塞","children":[],"parent":"76d8f030deb4"},{"id":"c0832d5c3701","title":"其它阻塞","children":[],"parent":"76d8f030deb4"}],"parent":"a5db81c9f5a5"},{"id":"975bc5bb0577","title":"状态之间的相互转换","children":[],"parent":"a5db81c9f5a5"}],"parent":"root"},{"id":"8674bf1dffa0","title":"锁优化","parent":"root","children":[{"id":"3a5d9d66531d","title":"自旋锁","children":[{"id":"a7cde039f072","title":"什么是自旋锁？","parent":"3a5d9d66531d","children":[{"id":"d59dadcf9b51","title":"当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。","parent":"a7cde039f072","children":[]}]},{"id":"99ad479ab265","title":"自旋锁的优缺点？","parent":"3a5d9d66531d","children":[{"id":"9ca653245c9c","title":"优点：自旋锁尽可能的减少线程的阻塞，提升性能","parent":"99ad479ab265","children":[]},{"id":"936ee624c04d","title":"缺点：如果锁的竞争激烈，就会占用 cpu 做无用功，导致线程自旋的消耗大于线程阻塞挂起操作的消耗","children":[],"parent":"99ad479ab265"}]}],"parent":"8674bf1dffa0"},{"id":"2a2939c175cb","title":"偏向锁","parent":"8674bf1dffa0","children":[{"id":"e0ce10e85414","title":"让第一个获取锁对象的线程，之后再获取该锁时就不再需要进行同步操作，甚至连 CAS 操作也不再需要。但是，一旦有另外一个线程去尝试获取这个锁对象时，偏向状态就马上结束。此时撤销偏向（Revoke Bias）后，恢复到未锁定状态或者轻量级锁状态。","parent":"2a2939c175cb","children":[]}]},{"id":"35fd6596a5b7","title":"轻量级锁","children":[{"id":"abaa6fd08ef6","title":"轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来降低在无实际竞争的情况下，使用重量级锁产生的性能消耗。","children":[],"parent":"35fd6596a5b7"}],"parent":"8674bf1dffa0"},{"id":"c6a253c67ed7","title":"锁消除","parent":"8674bf1dffa0","children":[{"id":"a0e0cafff0c7","title":"锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。","children":[],"parent":"c6a253c67ed7"}]},{"id":"a0af537d41ab","title":"锁粗化","parent":"8674bf1dffa0","children":[{"id":"ba792b9677d0","title":"如果一系列的连续操作都对同一个对象反复加锁和解锁，那么频繁的加锁操作就会导致性能损耗。所以，我们可以把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。","children":[],"parent":"a0af537d41ab"}]}]}]}},"meta":{"id":"5fb655e0f346fb5f0e25e1b2","member":"5fa7ad757d9c081baf1d7fac","exportTime":"2020-11-20 19:58:37","diagramInfo":{"category":"mind_free","title":"多线程阶段学习总结","created":"2020-11-19 19:24:16","creator":"5fa7ad757d9c081baf1d7fac","modified":"2020-11-20 18:42:53"},"type":"ProcessOn Schema File","version":"1.0"}}